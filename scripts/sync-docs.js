#!/usr/bin/env node

/**
 * Documentation Sync Script
 * 
 * This script automatically syncs documentation from the dashboard repository
 * during the website build process. It:
 * 1. Pulls the latest dashboard repo
 * 2. Reads all documentation files
 * 3. Generates the documentation importer with current content
 * 4. Updates the website with latest documentation
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const DASHBOARD_REPO_PATH = path.resolve(__dirname, '../../dashboard');
const OUTPUT_FILE = path.resolve(__dirname, '../src/utils/documentationImporter.js');
const DOCS_DIR = path.join(DASHBOARD_REPO_PATH, 'docs');

// Documentation files to sync
const DOC_FILES = [
  'SYSTEM_OVERVIEW.md',
  'API_DOCUMENTATION.md',
  'QUICKSTART.md',
  'ONBOARDING_GUIDE.md',
  'CLI_CONSISTENCY_STANDARDS.md',
  'QUICK_REFERENCE.md'
];

/**
 * Pull latest changes from dashboard repo
 */
function pullDashboardRepo() {
  console.log('üîÑ Pulling latest dashboard repository...');
  
  try {
    // Check if dashboard repo exists
    if (!fs.existsSync(DASHBOARD_REPO_PATH)) {
      throw new Error(`Dashboard repository not found at: ${DASHBOARD_REPO_PATH}`);
    }
    
    // Change to dashboard directory and pull latest changes
    const originalCwd = process.cwd();
    process.chdir(DASHBOARD_REPO_PATH);
    
    // Git pull latest changes
    execSync('git pull origin main', { stdio: 'inherit' });
    
    // Return to original directory
    process.chdir(originalCwd);
    
    console.log('‚úÖ Dashboard repository updated successfully');
  } catch (error) {
    console.error('‚ùå Failed to pull dashboard repository:', error.message);
    throw error;
  }
}

/**
 * Read documentation file content
 */
function readDocFile(fileName) {
  const filePath = path.join(DOCS_DIR, fileName);
  
  if (!fs.existsSync(filePath)) {
    console.warn(`‚ö†Ô∏è  Documentation file not found: ${fileName}`);
    return null;
  }
  
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    console.log(`üìñ Read documentation: ${fileName}`);
    return content;
  } catch (error) {
    console.error(`‚ùå Failed to read ${fileName}:`, error.message);
    return null;
  }
}

/**
 * Generate documentation metadata
 */
function generateMetadata(fileName) {
  const metadata = {
    'SYSTEM_OVERVIEW.md': {
      title: 'System Overview',
      description: 'Architecture and component overview of the MyBitcoinFuture system',
      category: 'Getting Started'
    },
    'API_DOCUMENTATION.md': {
      title: 'API Documentation',
      description: 'Complete REST API reference and integration guides',
      category: 'API Documentation'
    },
    'QUICKSTART.md': {
      title: 'Quick Start Guide',
      description: 'Fast deployment and configuration guide',
      category: 'Getting Started'
    },
    'ONBOARDING_GUIDE.md': {
      title: 'Onboarding Guide',
      description: 'Enhanced setup and configuration process',
      category: 'Getting Started'
    },
    'CLI_CONSISTENCY_STANDARDS.md': {
      title: 'CLI Standards',
      description: 'Command-line interface consistency standards',
      category: 'Development'
    },
    'QUICK_REFERENCE.md': {
      title: 'Quick Reference',
      description: 'Essential CLI commands and API endpoints',
      category: 'Reference'
    }
  };
  
  return metadata[fileName] || {
    title: fileName.replace('.md', ''),
    description: 'Documentation',
    category: 'Other'
  };
}

/**
 * Generate the documentation importer file
 */
function generateDocumentationImporter(docContent) {
  const lastUpdated = new Date().toISOString().split('T')[0];
  
  const fileContent = `/**
 * Documentation Importer Utility
 * 
 * This utility helps synchronize website documentation with dashboard documentation
 * by providing functions to import and adapt dashboard markdown content for the website.
 * 
 * AUTO-GENERATED: This file is automatically generated during build time.
 * Do not edit manually - changes will be overwritten.
 * 
 * Last Updated: ${lastUpdated}
 */

import Fuse from 'fuse.js';

// Cache for documentation content
const documentationCache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

/**
 * Get documentation metadata
 * @param {string} docPath - Path to the documentation file
 * @returns {object} - Metadata about the documentation
 */
export const getDocumentationMetadata = (docPath) => {
  const fileName = docPath.split('/').pop();
  
  const metadata = {
${Object.entries(docContent)
  .filter(([fileName, content]) => content !== null)
  .map(([fileName]) => {
    const meta = generateMetadata(fileName);
    return `    '${fileName}': {
      title: '${meta.title}',
      description: '${meta.description}',
      category: '${meta.category}',
      lastUpdated: '${lastUpdated}'
    }`;
  })
  .join(',\n')}
  };
  
  return metadata[fileName] || {
    title: fileName.replace('.md', ''),
    description: 'Documentation',
    category: 'Other',
    lastUpdated: '${lastUpdated}'
  };
};

/**
 * Import dashboard documentation content from local store
 * @param {string} docPath - Path to the documentation file (e.g., 'SYSTEM_OVERVIEW.md')
 * @returns {Promise<string>} - The documentation content
 */
export const importDashboardContent = async (docPath) => {
  const fileName = docPath.split('/').pop();
  
  // Local content store with actual dashboard documentation
  const localDocumentationContent = {
${Object.entries(docContent)
  .filter(([fileName, content]) => content !== null)
  .map(([fileName, content]) => {
    // Escape backticks and template literals
    const escapedContent = content
      .replace(/\\/g, '\\\\')
      .replace(/\`/g, '\\`')
      .replace(/\$/g, '\\$');
    
    return `    '${fileName}': \`${escapedContent}\``;
  })
  .join(',\n')}
  };
  
  if (localDocumentationContent[fileName]) {
    return localDocumentationContent[fileName];
  }
  
  return \`# Documentation Not Available

This documentation file could not be found: \${fileName}

Please check the available documentation files or contact support.

Last Updated: ${lastUpdated}\`;
};

/**
 * Parse markdown content for website display
 * @param {string} markdown - Raw markdown content
 * @returns {object} - Parsed content with sections and metadata
 */
export const parseMarkdownForWebsite = (markdown) => {
  const lines = markdown.split('\\n');
  const sections = [];
  let currentSection = null;
  
  for (const line of lines) {
    if (line.startsWith('# ')) {
      // Main title
      if (currentSection) {
        sections.push(currentSection);
      }
      currentSection = {
        type: 'title',
        level: 1,
        content: line.substring(2),
        children: []
      };
    } else if (line.startsWith('## ')) {
      // Section header
      if (currentSection) {
        sections.push(currentSection);
      }
      currentSection = {
        type: 'section',
        level: 2,
        content: line.substring(3),
        children: []
      };
    } else if (line.startsWith('### ')) {
      // Subsection header
      if (currentSection) {
        currentSection.children.push({
          type: 'subsection',
          level: 3,
          content: line.substring(4)
        });
      }
    } else if (line.trim() !== '') {
      // Content
      if (currentSection) {
        currentSection.children.push({
          type: 'content',
          content: line
        });
      }
    }
  }
  
  if (currentSection) {
    sections.push(currentSection);
  }
  
  return {
    sections,
    raw: markdown
  };
};

/**
 * Search documentation content using Fuse.js with local content
 * @param {string} query - Search query
 * @returns {Promise<Array>} - Search results with relevance scores
 */
export const searchDocumentation = async (query) => {
  if (!query || query.trim() === '') {
    return [];
  }
  
  try {
    // Get all available documentation files
    const docFiles = [
${Object.keys(docContent)
  .filter(fileName => docContent[fileName] !== null)
  .map(fileName => `      '${fileName}'`)
  .join(',\n')}
    ];
    
    // Get content for all files
    const documents = await Promise.all(
      docFiles.map(async (fileName) => {
        const content = await importDashboardContent(fileName);
        return {
          fileName,
          content,
          title: getDocumentationMetadata(fileName).title,
          description: getDocumentationMetadata(fileName).description,
          category: getDocumentationMetadata(fileName).category
        };
      })
    );
    
    // Configure Fuse.js for fuzzy search
    const fuseOptions = {
      keys: [
        { name: 'title', weight: 0.7 },
        { name: 'description', weight: 0.3 },
        { name: 'content', weight: 0.1 }
      ],
      threshold: 0.3,
      includeScore: true,
      includeMatches: true,
      minMatchCharLength: 2,
      findAllMatches: true
    };
    
    // Create Fuse instance with local content
    const fuse = new Fuse(documents, fuseOptions);
    const results = fuse.search(query);
    
    return results.map(result => ({
      docPath: result.item.fileName,
      metadata: getDocumentationMetadata(result.item.fileName),
      relevance: 1 - result.score, // Convert Fuse score to relevance (0-1)
      matches: result.matches
    }));
  } catch (error) {
    console.error('Search failed:', error);
    return [];
  }
};

/**
 * Preload common documentation files for better performance
 */
export const preloadCommonDocs = async () => {
  const commonDocs = ['SYSTEM_OVERVIEW.md', 'QUICKSTART.md'];
  
  try {
    await Promise.all(commonDocs.map(doc => importDashboardContent(doc)));
    console.log('Common documentation preloaded successfully');
  } catch (error) {
    console.error('Failed to preload common docs:', error);
  }
};

/**
 * Clear documentation cache
 */
export const clearDocumentationCache = () => {
  documentationCache.clear();
  console.log('Documentation cache cleared');
};

export default {
  importDashboardContent,
  parseMarkdownForWebsite,
  getDocumentationMetadata,
  searchDocumentation,
  preloadCommonDocs,
  clearDocumentationCache
};
`;

  return fileContent;
}

/**
 * Main sync function
 */
function syncDocumentation() {
  console.log('üöÄ Starting documentation sync...');
  
  try {
    // Step 1: Pull latest dashboard repo
    pullDashboardRepo();
    
    // Step 2: Read all documentation files
    console.log('üìñ Reading documentation files...');
    const docContent = {};
    
    for (const fileName of DOC_FILES) {
      const content = readDocFile(fileName);
      docContent[fileName] = content;
    }
    
    // Step 3: Generate the documentation importer
    console.log('üî® Generating documentation importer...');
    const importerContent = generateDocumentationImporter(docContent);
    
    // Step 4: Write the file
    console.log('üíæ Writing documentation importer...');
    fs.writeFileSync(OUTPUT_FILE, importerContent, 'utf8');
    
    // Step 5: Summary
    const successfulFiles = Object.values(docContent).filter(content => content !== null).length;
    console.log(`‚úÖ Documentation sync complete!`);
    console.log(`üìä Synced ${successfulFiles}/${DOC_FILES.length} documentation files`);
    console.log(`üìÅ Output: ${OUTPUT_FILE}`);
    
  } catch (error) {
    console.error('‚ùå Documentation sync failed:', error.message);
    process.exit(1);
  }
}

// Run the sync if this script is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  syncDocumentation();
}

export { syncDocumentation };
