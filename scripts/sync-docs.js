#!/usr/bin/env node

/**
 * Documentation Sync Script
 * 
 * This script automatically syncs documentation from the dashboard repository
 * during the website build process. It:
 * 1. Pulls the latest dashboard repo
 * 2. Reads all documentation files
 * 3. Generates the documentation importer with current content
 * 4. Updates the website with latest documentation
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const DASHBOARD_REPO_PATH = path.resolve(__dirname, '../../dashboard');
const OUTPUT_FILE = path.resolve(__dirname, '../src/utils/documentationImporter.js');
const DOCS_DIR = path.join(DASHBOARD_REPO_PATH, 'docs');

// Documentation files to sync
const DOC_FILES = [
  'SYSTEM_OVERVIEW.md',
  'API_DOCUMENTATION.md',
  'QUICKSTART.md',
  'ONBOARDING_GUIDE.md',
  'CLI_CONSISTENCY_STANDARDS.md',
  'QUICK_REFERENCE.md'
];

/**
 * Pull latest changes from dashboard repo
 */
function pullDashboardRepo() {
  console.log('üîÑ Pulling latest dashboard repository...');
  
  try {
    // Check if dashboard repo exists
    if (!fs.existsSync(DASHBOARD_REPO_PATH)) {
      throw new Error(`Dashboard repository not found at: ${DASHBOARD_REPO_PATH}`);
    }
    
    // Change to dashboard directory and pull latest changes
    const originalCwd = process.cwd();
    process.chdir(DASHBOARD_REPO_PATH);
    
    // Git pull latest changes
    execSync('git pull origin main', { stdio: 'inherit' });
    
    // Return to original directory
    process.chdir(originalCwd);
    
    console.log('‚úÖ Dashboard repository updated successfully');
  } catch (error) {
    console.error('‚ùå Failed to pull dashboard repository:', error.message);
    throw error;
  }
}

/**
 * Read documentation file content
 */
function readDocFile(fileName) {
  const filePath = path.join(DOCS_DIR, fileName);
  
  if (!fs.existsSync(filePath)) {
    console.warn(`‚ö†Ô∏è  Documentation file not found: ${fileName}`);
    return null;
  }
  
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    console.log(`üìñ Read documentation: ${fileName}`);
    return content;
  } catch (error) {
    console.error(`‚ùå Failed to read ${fileName}:`, error.message);
    return null;
  }
}

/**
 * Generate documentation metadata
 */
function generateMetadata(fileName) {
  const metadata = {
    'SYSTEM_OVERVIEW.md': {
      title: 'System Overview',
      description: 'Architecture and component overview of the MyBitcoinFuture system',
      category: 'Getting Started'
    },
    'API_DOCUMENTATION.md': {
      title: 'API Documentation',
      description: 'Complete REST API reference and integration guides',
      category: 'API Documentation'
    },
    'QUICKSTART.md': {
      title: 'Quick Start Guide',
      description: 'Fast deployment and configuration guide',
      category: 'Getting Started'
    },
    'ONBOARDING_GUIDE.md': {
      title: 'Onboarding Guide',
      description: 'Enhanced setup and configuration process',
      category: 'Getting Started'
    },
    'CLI_CONSISTENCY_STANDARDS.md': {
      title: 'CLI Consistency Standards',
      description: 'Command-line interface standards and best practices',
      category: 'Development'
    },
    'QUICK_REFERENCE.md': {
      title: 'Quick Reference',
      description: 'Essential CLI commands and API endpoints',
      category: 'Reference'
    }
  };
  
  return metadata[fileName] || {
    title: fileName.replace('.md', ''),
    description: 'Documentation',
    category: 'Other'
  };
}

/**
 * Generate documentation importer content
 */
function generateDocumentationImporter(docContents) {
  const timestamp = new Date().toISOString();
  
  let content = `/**
 * Documentation Importer Utility
 * 
 * This utility helps synchronize website documentation with dashboard documentation
 * by providing functions to import and adapt dashboard markdown content for the website.
 * 
 * AUTO-GENERATED: This file is automatically generated during build time.
 * Do not edit manually - changes will be overwritten.
 * 
 * Last Updated: ${timestamp.split('T')[0]}
 */

// Local content store with actual dashboard documentation
const LOCAL_DOCUMENTATION_CONTENT = {
`;

  // Add documentation content
  Object.entries(docContents).forEach(([fileName, content]) => {
    if (content) {
      // Escape backticks and quotes for JavaScript string
      const escapedContent = content
        .replace(/\\/g, '\\\\')
        .replace(/`/g, '\\`')
        .replace(/\$/g, '\\$');
      
      content += `  '${fileName}': \`${escapedContent}\`,
`;
    }
  });

  content += `};

/**
 * Get documentation metadata
 * @param {string} docPath - Path to the documentation file
 * @returns {object} - Metadata about the documentation
 */
export const getDocumentationMetadata = (docPath) => {
  const fileName = docPath.split('/').pop();
  
  const metadata = {
`;

  // Add metadata
  Object.entries(docContents).forEach(([fileName, content]) => {
    if (content) {
      const metadata = generateMetadata(fileName);
      content += `    '${fileName}': {
      title: '${metadata.title}',
      description: '${metadata.description}',
      category: '${metadata.category}',
      lastUpdated: '${timestamp.split('T')[0]}'
    },
`;
    }
  });

  content += `  };
  
  return metadata[fileName] || {
    title: fileName.replace('.md', ''),
    description: 'Documentation',
    category: 'Other',
    lastUpdated: '${timestamp.split('T')[0]}'
  };
};

/**
 * Import dashboard documentation content from local store
 * @param {string} docPath - Path to the documentation file (e.g., 'SYSTEM_OVERVIEW.md')
 * @returns {Promise<string>} - The documentation content
 */
export const importDashboardContent = async (docPath) => {
  const fileName = docPath.split('/').pop();
  
  // Return content from local store
  const content = LOCAL_DOCUMENTATION_CONTENT[fileName];
  
  if (!content) {
    throw new Error(\`Documentation not found: \${fileName}\`);
  }
  
  return content;
};

/**
 * Search documentation content
 * @param {string} query - Search query
 * @param {Array<string>} docPaths - Array of documentation paths to search
 * @returns {Promise<Array>} - Search results
 */
export const searchDocumentation = async (query, docPaths = []) => {
  if (!query || query.trim() === '') {
    return [];
  }
  
  const results = [];
  
  for (const docPath of docPaths) {
    try {
      const content = await importDashboardContent(docPath);
      const fileName = docPath.split('/').pop();
      const metadata = getDocumentationMetadata(docPath);
      
      // Simple text search
      const searchIndex = content.toLowerCase();
      const queryLower = query.toLowerCase();
      
      if (searchIndex.includes(queryLower)) {
        // Find the first occurrence for context
        const index = searchIndex.indexOf(queryLower);
        const start = Math.max(0, index - 100);
        const end = Math.min(content.length, index + query.length + 100);
        const snippet = content.substring(start, end);
        
        results.push({
          docPath,
          fileName,
          title: metadata.title,
          description: metadata.description,
          category: metadata.category,
          snippet: snippet.trim(),
          relevance: 1
        });
      }
    } catch (error) {
      console.warn(\`Failed to search \${docPath}:\`, error.message);
    }
  }
  
  return results.sort((a, b) => b.relevance - a.relevance);
};

/**
 * Get all available documentation
 * @returns {Promise<Array>} - Array of documentation metadata
 */
export const getAllDocumentation = async () => {
  const docs = [];
  
  for (const fileName of Object.keys(LOCAL_DOCUMENTATION_CONTENT)) {
    const metadata = getDocumentationMetadata(fileName);
    docs.push({
      docPath: fileName,
      fileName,
      ...metadata
    });
  }
  
  return docs.sort((a, b) => a.title.localeCompare(b.title));
};

export default {
  importDashboardContent,
  searchDocumentation,
  getAllDocumentation,
  getDocumentationMetadata
};
`;

  return content;
}

/**
 * Main execution
 */
function main() {
  console.log('üöÄ Starting documentation sync...');
  
  try {
    // Pull latest dashboard repo
    pullDashboardRepo();
    
    // Read all documentation files
    console.log('üìñ Reading documentation files...');
    const docContents = {};
    
    for (const fileName of DOC_FILES) {
      const content = readDocFile(fileName);
      if (content) {
        docContents[fileName] = content;
      }
    }
    
    // Generate documentation importer
    console.log('üî® Generating documentation importer...');
    const importerContent = generateDocumentationImporter(docContents);
    
    // Write to output file
    console.log('üíæ Writing documentation importer...');
    fs.writeFileSync(OUTPUT_FILE, importerContent, 'utf8');
    
    console.log('‚úÖ Documentation sync complete!');
    console.log(`üìä Synced ${Object.keys(docContents).length}/${DOC_FILES.length} documentation files`);
    console.log(`üìÅ Output: ${OUTPUT_FILE}`);
    
  } catch (error) {
    console.error('‚ùå Documentation sync failed:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
