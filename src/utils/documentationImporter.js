/**
 * Documentation Importer Utility
 * 
 * This utility helps synchronize website documentation with dashboard documentation
 * by providing functions to import and adapt dashboard markdown content for the website.
 * 
 * AUTO-GENERATED: This file is automatically generated during build time.
 * Do not edit manually - changes will be overwritten.
 * 
 * Last Updated: 2025-08-24
 */

import Fuse from 'fuse.js';

// Cache for documentation content
const documentationCache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

/**
 * Get documentation metadata
 * @param {string} docPath - Path to the documentation file
 * @returns {object} - Metadata about the documentation
 */
export const getDocumentationMetadata = (docPath) => {
  const fileName = docPath.split('/').pop();
  
  const metadata = {
  };
  
  return metadata[fileName] || {
    title: fileName.replace('.md', ''),
    description: 'Documentation',
    category: 'Other',
    lastUpdated: '2025-08-24'
  };
};

/**
 * Import dashboard documentation content from local store
 * @param {string} docPath - Path to the documentation file (e.g., 'SYSTEM_OVERVIEW.md')
 * @returns {Promise<string>} - The documentation content
 */
export const importDashboardContent = async (docPath) => {
  const fileName = docPath.split('/').pop();
  
  // Local content store with actual dashboard documentation
  const localDocumentationContent = {
  };
  
  // Return content from local store
  const content = localDocumentationContent[fileName];
  
  if (!content) {
    throw new Error(`Documentation not found: ${fileName}`);
  }
  
  return content;
};

/**
 * Search documentation content
 * @param {string} query - Search query
 * @param {Array<string>} docPaths - Array of documentation paths to search
 * @returns {Promise<Array>} - Search results
 */
export const searchDocumentation = async (query, docPaths = []) => {
  if (!query || query.trim() === '') {
    return [];
  }
  
  const results = [];
  
  for (const docPath of docPaths) {
    try {
      const content = await importDashboardContent(docPath);
      const fileName = docPath.split('/').pop();
      const metadata = getDocumentationMetadata(docPath);
      
      // Simple text search
      const searchIndex = content.toLowerCase();
      const queryLower = query.toLowerCase();
      
      if (searchIndex.includes(queryLower)) {
        // Find the first occurrence for context
        const index = searchIndex.indexOf(queryLower);
        const start = Math.max(0, index - 100);
        const end = Math.min(content.length, index + query.length + 100);
        const snippet = content.substring(start, end);
        
        results.push({
          docPath,
          fileName,
          title: metadata.title,
          description: metadata.description,
          category: metadata.category,
          snippet: snippet.trim(),
          relevance: 1
        });
      }
    } catch (error) {
      console.warn(`Failed to search ${docPath}:`, error.message);
    }
  }
  
  return results.sort((a, b) => b.relevance - a.relevance);
};

/**
 * Get all available documentation
 * @returns {Promise<Array>} - Array of documentation metadata
 */
export const getAllDocumentation = async () => {
  const docs = [];
  
  for (const fileName of Object.keys(localDocumentationContent)) {
    const metadata = getDocumentationMetadata(fileName);
    docs.push({
      docPath: fileName,
      fileName,
      ...metadata
    });
  }
  
  return docs.sort((a, b) => a.title.localeCompare(b.title));
};

export default {
  importDashboardContent,
  searchDocumentation,
  getAllDocumentation,
  getDocumentationMetadata
};
